问题列表
- rollup和webpack的区别？
- 什么是编译器，作用是什么？


# ★调试设置

打包工具

vue源码用的rollup

webpack会打包出来浏览器需要的东模块化的代码，会存在冗余代码，相比rollup更轻量

开发库的时候适合用roolup，开发项目的时候适合webpack



# 编译器和运行时

## 编译器

编译器就是将template模板字符串转换成javascript渲染函数的代码，就是render函数，render函数的作用是生成虚拟dom，【体积大，效率低】编译器源代码有3000多行，

## 运行时
运行时是创建vue实例、渲染并处理虚拟DOM等代码，也就是不包含编译器，编译器源代码有3000多行，因为不包含编译器，所以体积小，效率高，

   -  runtime的就是不包含编译器的文件，只是运行时，

   -  full，就是带编译器的打包出来的文件xin

   -  common 的就是支持commonjs的

   -  esm  的就是支持esmodule的


使用vue-cli运行的项目最终创建的时候都是使用的 esmodule 运行时的版本 vue.runtime.esm.js



vue-cli对webpack做了一个深度的封装，想要看需要执行命令 vue inspect

**vue inspect > output.js**

不是一个有效的vue配置文件，反正vuecli就是使用的是这个js，运行时版本  vue.runtime.esm.js


> 单文件组件 APP.vue  会把这种转换成js对象，转换js对象的时候，还会把这template模板转换成render函数，所以单文件也是不需要编译器的，所以再使用vue创建项目的时候都推进运行时版本


# 寻找入口文件

- 1. npm run dev  package.json
- 2. scripts/config.js  web-full-dev
- 3. web/entry-runtime-with-compiler.js

## vue初始化过程

- 4. src/platforms/web/entry-runtime-with-compiler.js  web相关、重写$mount、注册vue.compile
- 5. ./runtime/index  src/platforms/web/runtime/index.js  web相关、注册全局指令、全局组件、全局方法__patch__、$mount挂载方法
- 6. core/index  与平台无关、设置vue静态方法  initGlobalAPI
- 7. ./instance/index  src/core/instance/index.js  与平台无关，定义构造函数，调用this._init


> patch函数是把虚拟dom转换成dom的过程，然后再挂载el上 
>
> mountComponents渲染dom



# vue的静态成员

core/index.js----initGlobalAPI(Vue)
















# 实例成员